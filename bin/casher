#!/usr/bin/env ruby --disable=gems --disable=rubyopt
GC.disable # yolo

require 'optparse'
require 'shellwords'
require 'fileutils'

class Casher
  SEED = 1386246902
  ALGORITHMS = {
    nop:       nil,
    crc:       %w[ cksum      sum        ],
    detect:    %w[ tigerdeep  md5sum     ],
    md5:       %w[ md5deep    md5sum     ],
    sha1:      %w[ sha1deep   sha1sum    ],
    sha224:    %w[ sha224                ],
    sha256:    %w[ sha256depp sha256sum  ],
    sha384:    %w[ sha384sum             ],
    sha512:    %w[ sha384sum             ],
    tiger:     %w[ tigerdeep             ],
    whirlpool: %w[ whirlpooldeep         ]
  }

  attr_accessor :headers, :check_mtime, :algorithm, :debug, :casher_dir
  alias_method :check_mtime?, :check_mtime
  alias_method :debug?, :debug

  def self.find(name)
    constant = constants.detect { |c| c.name.to_s.downcase == name }
    const_get(constant || name).new
  end

  def self.run(*args)
    command = nil
    casher  = new
    parser  = OptionParser.new
    append  = ?!
    parser.banner = "Usage: casher [options] command [arguments]"
    parser.on("-H", "--header VALUE", "add given header to HTTP requests") { |h| casher.headers << h }
    parser.on("-m", "--check-mtime", "use mtime as indicator if a file changed") { casher.check_mtime = true }
    parser.on("-M", "--no-check-mtime", "don't use mtime as indicator if a file changed") { casher.check_mtime = false }
    parser.on("-a", "--algorithm NAME", "checksum algorithm to use for detecting changes") { |a| casher.algorithm = a.to_sym }
    parser.on("-d", "--debug", "print helpful debug output, show stacktraces") { casher.debug = true }
    parser.on("-i", "--internal", "run internal command") { append = "" }
    parser.on("-g", "--enable-gc", "enable Garbage collector") { GC.enable }
    parser.on("-c", "--casher-dir PATH", "set directory for archives and meta data") { |p| casher.casher_dir = p }
    parser.on("-?", "-h", "--help", "display help") { command = "help" }
    parser.parse! args
    raise "missing command"            unless command ||= args.shift and method = command + append
    raise "unknown command #{command}" unless casher.respond_to? method or casher.debug?
    args.unshift(parser.help) if command == "help"
    casher.public_send(method, *args)
  rescue => error
    raise error if casher.debug?
    $stderr.puts error.message
    exit 1
  end

  def initialize
    @casher_dir  = ENV['CASHER_DIR'] || File.expand_path("~/.casher")
    @headers     = []
    @check_mtime = true
    @algorithm   = :detect
  end

  def help!(text)
    puts <<-HELP.gsub(/^      |\n\Z/, '')
      #{text}
      Available commands:
          #{public_methods.sort.map { |m| m.to_s[/(.+)!/, 1] }.compact.join(", ")}.

      Available checksum algorithms:
          #{ALGORITHMS.keys.sort.join(", ")}.

      If set to detect, it will use tiger, md5 or crc, depending on availability.
      If set to nop, files will be assumed to have changed.
    HELP
  end

  def checksums!(*paths)
    checksums(*paths).each { |k,v| puts "#{v} #{k}" }
  end

  def extract!(*paths)
    puts "reading from cache: #{paths.map(&:inspect).join(", ")}"
    extract(*paths) { puts(*tar_error.scan(/^tar: (.*:.*)$/i)) }
  end

  def checksums(*paths)
    return {} if paths.empty?
    return dummy_checksums(*paths) unless commands = ALGORITHMS.fetch(algorithm) { raise "unknown algorithm %s" % algorithm }
    raise "#{algorithm} not available" unless command = commands.detect { |c| system "which #{c} >/dev/null" }
    command = command.end_with?('deep') ? "#{command} -r #{_ paths}" : "find #{_ paths} -type f | xargs #{command}"
    output  = `#{command} 2>/dev/null`
    Hash[output.each_line.map { |l| l.chomp.split(" ", 2).reverse }]
  end

  def debug(*lines)
    lines.each { |l| $stderr.puts("* #{l}") } if debug?
  end

  def console
    require 'rubygems' unless defined? Gem
    require 'pry'
    binding.pry
  end

  private

    def dummy_checksums(*paths)
      checksum = ((Time.now-SEED).to_f*(10**10)).to_i.to_s(32)
      Hash[paths.each_with_object(checksum).to_a]
    end

    def extract(*paths)
      tar(:x, "foo", *paths) { yield if block_given? }
    end

    def load_object(name, default = nil)
      content = load_file("#{name}.dump")
      content ? Marshal.load(content) : default
    end

    def store_object(name, content)
      store_file("#{name}.dump", Marshal.dump(content))
    end

    def load_file(name)
      path = file(name)
      File.read(path) if File.readable? path
    end

    def store_file(name, content, *args)
      File.write(file(name), content, *args)
    end

    def file(name, base = casher_dir)
      File.expand_path(name, base)
    end

    def time
      return yield unless debug?
      last_pid = $?.pid if $?
      start    = Time.now
      result   = yield
      duration = Time.now - start
      debug "  exit status: #{$?.exitstatus}" if $? and $?.pid != last_pid
      debug "  took %.3f seconds" % duration
      result
    end

    def system(input)
      debug("$ #{input}")
      time { super }
    end

    def `(input)
      debug("$ #{input}")
      time { super }
    end

    def _(input)
      Array === input ? Shellwords.join(input) : Shellwords.escape(input)
    end

  run(*ARGV)
end
